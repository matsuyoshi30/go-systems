ファイルシステムの最深部を扱うGo言語の関数

- ファイルの変更監視（syscall.Inotify）
  ローカルファイルの変更については以下2種類の検知方法がある
  - 監視したいファイルをOSに通知しておいて、変更があったら教えてもらう（パッシブ）
    各OSでコードの差が大きくなる
  - 定期的にディレクトリ内を走査し、os.Stat()など使って変更を探索する（アクティブ）
    監視対象が増えるとその分バッテリー消耗が激しくなる
  サードパーティパッケージの gopkg.in/fsnotify.v1 つかってパッシブ方式かつOS間のコードの差をなくす
  [サンプルコード](./fsnotify)

- ファイルのロック（syscall.Flock()）
  複数プロセスで同一リソースをいじらないよう、「いまこれいじってます」というのを他のプロセスに伝える手法の一つ
  ファイルロックのシステムコールを使用して、既に存在するファイルに対してロックをかける
  ロックが取得できればファイルをいじれるし、取得できなければ他プロセスがロックしていることがわかる
  ロックのフラグを使い分け、「読み込み（共有ロック）は平行アクセスOKで、書き込み（排他ロック）は1プロセスのみ許可」を実現する
  [サンプルコード](./flock)
  `go build`してから`./flock`で実行

- ファイルのメモリへのマッピング（syscall.Mmap()）
  os.Fileはランダムアクセス可能だけど読み込み位置をテープのようにいちいち移動しないといけない
  syscall.Mmap()システムコール使えばファイルの内容をメモリに展開できるのでメモリ上で処理可能
  [サンプルコード](./mmap)
  先頭から順に読み込む場合はFile.Read()の方で充分速い。データ全体をメモリに展開して処理する必要があるならmmap()

- 同期・非同期/ブロッキング・ノンブロッキング
  ファイルI/OもネットワークI/OもCPU内部ではめちゃ遅いタスクなのでボトルネックになってしまう
  OSのシステムコールで解決するための仕組み
  同期・非同期は実データを取りに行くのか通知をもらうかの区別
  - 同期  : OSにI/Oタスクを投げて、入出力の準備が出来たらアプリが返ってくる
  - 非同期: OSにI/Oタスクを投げて、入出力の準備が出来たら通知をもらう
  ブロッキング・ノンブロッキングはタスクの結果の受け取り方で区別
  - ブロッキング    : お願いしたI/Oタスクの結果の準備ができるまで待つ（自分は停止）
  - ノンブロッキング: お願いしたI/Oタスクの結果の準備ができるのを待たない（自分は停止しない）
  ということで、
  - 同期・ブロッキング: 読み込み、書き込みが完了するまで待つ（基本的かつわかりやすい）
  - 同期・ノンブロッキング: プロセス側がOSから完了が返ってくるまでAPIを呼ぶ（ポーリング）
  - 非同期・ブロッキング: I/O多重化。準備ができたものからおしえてもらうイベント駆動
  - 非同期・ノンブロッキング: 別スレッドで処理を行い、完了したら通知だけ受け取る
  Goのベースはシンプルな同期・ブロッキングインターフェースだけど、
  - goroutine使ってそれぞれに同期・ブロッキングI/Oを担当させれば、非同期・ノンブロッキングに
  - goroutineで並行化させたI/Oの入出力でチャネル使えば、他のgoroutineとやり取りする箇所のみが同期
  - チャネルにバッファがあれば、書き込み側もノンブロッキング
  - チャネルでselect使えば非同期・ブロッキングのI/O多重化になる
  - selectにdefaultあると読み込みをノンブロッキングで実施できる＝非同期I/O化

- select属のシステムコールによるI/O多重化
  I/O多重化は万単位の入出力を効率よく扱える
  POSIXではselectやpollといったシステムコールがあるが、どれも微妙（性能とか移植性とか）
  現状では各OSのいい感じのシステムコールを使って多重I/Oを実現するのが定石
  [サンプルコード](./iomultiplex)