Go言語と並行処理

- 複数の仕事を同時に行うとは？
  並行(Concurrent): CPU数、コア数の限界を越えて複数の仕事を同時に行う。同時にいくつかの質の異なることを扱う
  並列(Parallel):   複数のCPU、コアを効率よく扱って計算速度を上げる。同時にいくつかの質の同じことを扱う
  -> CPUにおける処理時間が大きい（ユーザー時間が支配的）場合は並列、I/O待ちなどでCPUが暇しているときは並行、が基本

- Goの並列処理のための道具
  goroutineで情報共有方法としてチャネルを使う
  goroutineの起動はOSのネイティブスレッドより高速だが、コストゼロではない
    単純なループと比較するとgoroutineの起動が遅いので、クロージャを使ってキャプチャすると、ループが回るたびに意図したものとは別のデータを参照してしまう
    -> 関数の引数経由で明示的に値コピーが行われるようにすべし
  子のgoroutineから親へは、引数やクロージャで渡したデータ構造に書き込むか、クロージャでキャプチャした変数に書き込んでデータを渡す

- スレッドとgoroutineの違い
  プログラムから見たスレッド＝メモリにロードされたプログラムの現在の実行状態を持つ仮想CPU
  OSやCPUから見たスレッド＝時間が凍結されたプログラムの実行状態
  通常のスレッドはCPUコアに対してマッピングされるが、goroutineはOSのスレッドにマッピングされる

- GoのランタイムはミニOS
  「機能が少ない代わりにシンプルで起動が早いスレッド」をgoroutineとして提供している
  OSのスレッド(Go Machine)ごとにタスクであるgoroutineのリストがあり、実行中のスレッド上で順番にタスクを切り替えて実行
  -> Goのランタイムは、goroutineをスレッドとみなせばOSと同じ構造を持っていると考えることが出来る
  https://talks.godoc.org/github.com/niconegoto/talks/concurrency.slide

- runtimeパッケージのgoroutine関連の機能
  - runtime.LockOSThread()/runtime.UnlockOSThread()
    現在実行中のOSスレッドでのみgoroutineが実行される
    メインスレッドでの実行が強制されるGUIフレームワークやOpenGLライブラリなどをGoで利用するときに使う
    mainパッケージのinit()は確実にメインスレッドで実行されることを利用する
    Goのランタイムでは、シグナルを受け取るスレッドを固定するために利用している
  - runtime.Gosched()
    実行中のgoroutineを一時中断して他のgoroutineに処理を回す
  - runtime.GOMAXPROCS(n)/runtime.NumCPU()

- Race Detector
  データ競合を発見する機能
  `-race`オプションを付与して`go run`や`go build`を実行する

- syncパッケージ
  - sync.Mutex/sync.RWMutex
    マルチスレッドプログラミングでは、実行パスを保護するためにロックを使う
    sync.Mutexは、実行パスに入ることが可能なgoroutineを排他制御によって制限する
    「メモリを読み込んで書き換える」コードに入るgoroutineを一つに制限して不整合を防ぐ
    -> mapや配列に対する操作はアトミックでないため、複数のgoroutineからアクセスする際には保護が必要
    チャネルが有用: データの所有権を渡す場合、作業を並列化して分散する場合、非同期で結果を受け取る場合
    Mutexが有用: キャッシュ、状態管理
    -> https://github.com/golang/go/wiki/MutexOrChannel
    sync.RWMutexを使用すると、「読み込みはいくつものgoroutineが並列して実行でき、書き込み時は他のgoroutineの実行を許可しない」方式のロックが可能
    -> 読み込みと書き込みが同時に行われるような状態管理の場合はsync.Mutex
       複数のgoroutineで共有されるキャッシュの保護はsync.RWMutex
  - sync.WaitGroup
    多数のgoroutineで実行しているジョブの終了待ちに使用する
    ジョブ数が対象にあったり可変個の場合はチャネルよりもこっちの方が数値のカウントでスケールするので有用
  - sync.Once
    一度だけ関数を実行したいときに使う
    ＝初期化処理を一度だけ行いたいときとかに多い
    init()がパッケージ内にあれば初期化関数として呼ばれるので、そっちのほうがシンプル
    -> sync.Onceは初期化処理を必要なときまで遅延させたいときに使う
  - sync.Cond
    条件変数
    ロックをかけたり解除したりすることでクリティカルセクション（同時に実行されると問題が起こるコードの部分）を保護
    - 先に終わらせなければならないタスクがあり、それが完了したら待っているすべてのgoroutineに通知（Broadcast()）
    - リソースの準備ができ次第、それを待っているgoroutineに通知（Signal()）
      -> channel使えばよい
  - sync.Pool
    オブジェクトのキャッシュを実現する構造体
    一時的な状態を保持する構造体をプールしておいて、goroutine間でシェアが出来る
    Put()でキャッシュしたいデータを追加
    Get()でキャッシュからデータを取得
      プールが空のときは、プール作成時に設定した関数で作ったインスタンスが返ってくる
  - sync.Map
    組み込みのmapはアクセスをmapの外側でロックするので、操作するgoroutineを1つに限定しなければいけない
    sync.Mapは、ロックを内包し複数のgoroutineからアクセスされても壊れないことが保証されている

- sync/atomicパッケージ
  不可分操作を提供するパッケージ

並行と並列の本来の定義
並行: システムが複数の動作（処理の流れ）を同時に実行状態（in progress）に保てる機能を備えていること
      同時に実行自体になれる＝複数の動作はお互いに干渉し合わない＝1つの動作が他の動作をブロックしない
並列: 複数の動作を同時に実行できること
      同時実行できる＝2つの仕事に対して2つのコアがあれば2倍の性能が出せる

https://talks.golang.org/2015/simplicity-is-complicated.slide#1
-> Goが提供する並行・並列処理の3要素
   goroutine: 実行
   channel: コミュニケーション
   select: 調停（cooridation）
