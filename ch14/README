並行・並列処理の手法と設計のパターン

大まかには以下の4パターン
- マルチプロセス
  スクリプト言語でも使える
- イベント駆動
  I/O待ちが重いときに最適
- マルチスレッド
  性能が高い
- ストリーミング・プロセッシング
  性能が桁違いに高い
-> デザインを決めるときは、処理がCPUバウンドなのかI/Oバウンドなのかを判断し、改善したい箇所に当たりをつけた上で実装

詳細
- マルチプロセス
  プロセス間でメモリ空間がしっかりと分割されるので安全性が高い
  共有メモリやプロセス間通信、メッセージングキューの仕組みが必要
  コンテキストスイッチの実行コスト
- イベント駆動
  I/Oバウンドなプログラムで多用される並行処理
  単体ではCPUを使いこなしにくく、コードが複雑になりがち
- マルチスレッド
  同じメモリ空間内で多くのCPUが同時に実行するための仕組み
  (Linuxでは、親プロセスとメモリ空間を共有していなければプロセス、共有していたらスレッド)
  CPUのパフォーマンスで利点
  比較的大きなスタックメモリが必要となり、起動時間も少しかかる
  コンテキストスイッチの実行コスト
- ストリーミング・プロセッシング
  GPUのスレッディングモデル
  物量で攻める

- Goにおける並行・並列処理のパターン集
  並列化を導入するとどれだけ効率が改善するか＝アムダールの法則
  -> 並列化出来る仕事の割合が肝
  -> 逐次処理をなるべく分解し、同じ粒度のシンプルなたくさんのジョブに分けることが必要
     - 同期処理を非同期に
       重い処理をタスクに分ける
     - 非同期にしたものを同期化
       channel
       selectを使ってdefaultなしでイベント駆動、defaultありで非同期I/Oを実現
       sync.WaitGroup, sync.Cond, sync.Mutex
     - タスク生成と処理を分ける(Producer-Consumerパターン)
       channel
       プロセスをまたいで実現するにはメッセージキューというミドルウェアで仲介する(beanstalkdなど)
       Amazon SQSのようなクラウドサービスもある
     - 開始した順で処理(channelのchannel)
       FIFOのキューとしてchannelを使う
       channelの中に開始順にchannelを入れて、それぞれの子channelで終了を待つ
     - タスク処理が詰まったら待機(バックプレッシャー)
       channelのバッファサイズを、平常時は送信側がつまらない程度にする
       -> 詰まったら待機状態になる＝バックプレッシャーの実現
     - 並列なforループ
       ループ変数の実体は1つしかない
       -> goroutineの引数として渡し、goroutineごとにコピーが作成されるようにする必要がある
       ループ内部の処理が小さいとオーバーヘッドの方が大きくなる可能性もある
       CPUの負荷が重い場合は次のワーカープールを使用する
     - 決まった数のgoroutineでタスクを消化(ワーカープール)
       OSスレッドやフォークしたプロセスで多数の処理をこなすときは生成コストが課題となる時がある
       -> 事前にワーカーを作成してストックしておき、ワーカーが並列でタスクを消化していくようにする方法が有効
       =  事前に作成されるワーカー群をスレッドプール、プロセスプール、ワーカープールという
       CPUのコア数以上にgoroutineを作成してもスループットは向上しない
       -> CPUコア数分goroutineを作成して処理するのが効果的
     - 依存関係のあるタスクを表現(Future/Promise)
       依存関係のあるタスクをパイプラインとして表現し、実行可能なタスクから効率よく消化していく手法
       今はまだ得られていないけど将来得られるはずの入力(Future)を使ってロジックを作成
       将来値を提供するという約束(Promise)が果たされると、必要なデータが全て揃ったタスクが逐次実行される
       すべてのタスクをgoroutine、バッファなしチャネルでFuture、同じチャネルへの送信でPromiseを実現
       * JavaScriptのPromiseは出自が多少異なっていて非同期処理に特化している
     - イベントの流れを定義(ReactiveX)
       デザインパターンでいうオブザーバーパターンの少し賢いver
       https://github.com/ReactiveX/RxGo
     - 自立した複数のシステムで協調動作(アクターモデル)
       並列演算モデル
       自立した多数の小さなコンピューター（アクター）が強調して動作する
       各アクターは別のアクターから送られるメッセージを受け取るmailboxを持ち、そのメッセージをもとに協調動作する
       https://github.com/AsynkronIT/protoactor-go
       アクターはReceiveメソッドを持つ構造体
       Propsという生成方法を管理するオブジェクトを作成しておき、Spawn関数に渡すとアクターが作成され、そのアクターの識別子であるプロセスIDが作成される
       プロセスIDに対してTellメソッドを使ってメッセージを送信する
